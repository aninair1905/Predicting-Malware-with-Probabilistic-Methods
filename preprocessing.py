import pandas as pd
import numpy as np

def open_dataset(filepath):
    data = pd.read_csv(filepath)
    # drop NANs
    data = data.dropna()
    # filter columns whose values are constant
    data = data.loc[:, data.nunique() > 1]
    return data

def stratified_train_test_split(dataset, tr_frac, random_seed: int):

    y = dataset['Label'].values
    random_state = np.random.RandomState(random_seed)

    (gw_label, mw_label), (gw_size, mw_size) = np.unique(y, return_counts=True)

    # determine the number of samples for each class
    # goodware: 719 training and 180 testing
    gw_tr_size = int(gw_size * tr_frac)
    gw_te_size = gw_size - gw_tr_size

    # malware: 719 training and 2846 testing
    mw_tr_size = gw_tr_size
    mw_te_size = mw_size - mw_tr_size

    mw_idxs = np.where(y == mw_label)[0]
    gw_idxs = np.where(y == gw_label)[0]

    # randomly select the correct number of malware and goodware for training and testing
    random_state.shuffle(mw_idxs)
    random_state.shuffle(gw_idxs)
    mw_tr_idxs = mw_idxs[:mw_tr_size]
    gw_tr_idxs = gw_idxs[:gw_tr_size]
    mw_te_idxs = mw_idxs[mw_tr_size:]
    gw_te_idxs = gw_idxs[gw_tr_size:]

    tr_idxs = np.hstack((mw_tr_idxs, gw_tr_idxs))
    te_idxs = np.hstack((mw_te_idxs, gw_te_idxs))

    train_data = dataset.iloc[tr_idxs]
    test_data = dataset.iloc[te_idxs]

    # redefines 'malware' as integer 1 and 'goodware' as integer 0
    y_tr_N = (train_data['Label'] == mw_label).values.astype(int) 
    X_tr_NF = train_data.drop('Label', axis=1).values
    y_te_M = (test_data['Label'] == mw_label).values.astype(int)
    X_te_MF = test_data.drop('Label', axis=1).values

    # print sizes for sanity check!
    tr_counts = np.unique(y_tr_N, return_counts=True)
    te_counts = np.unique(y_te_M, return_counts=True)
    print(F'Class 0: {gw_label}\t Class 1: {mw_label}')
    print(F'Training Data:\t {tr_counts[1][0]} of class {tr_counts[0][0]}, {tr_counts[1][1]} of class {tr_counts[0][1]}')
    print(F'Testing Data:\t {te_counts[1][0]} of class {te_counts[0][0]}, {te_counts[1][1]} of class {te_counts[0][1]}')

    return X_tr_NF, X_te_MF, y_tr_N, y_te_M